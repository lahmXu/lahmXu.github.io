---
title: K8s Pod
tags:
  - k8s                   
categories:
- k8s 
---



**集装箱虽然好用，但是四面光秃秃的，吊车还怎么把这个集装箱吊起来并摆放好呢**

**Pod是Kubernetes调度的最小单元。一个Pod可以包含一个或多个容器，因此它可以被看作是内部容器的逻辑宿主机。**

**Pod不仅是一个对象，还是一种设计模式**

## 目录
	1. 为什么需要Pod？
	2. Pod的实现机制
	3. 详解容器设计模式	



##  为什么需要Pod？
### 容器设计模式
容器的设计本身是一种“单进程”模型，所以如果你在容器里启动多个进程，只有一个可以作为 PID=1 的进程，而这时候，如果这个 PID=1 的进程挂了，或者说失败退出了，那么其他三个进程就会自然而然的成为孤儿，没有人能够管理它们，没有人能够回收它们的资源，这是一个非常不好的情况。
当然你也可以将PID=1的进程改成systemd，但是这将会导致另外一个问题：使得管理容器不再是管理应用本身了，而等于是管理systemd，这样应用是否退出和异常是没办法直接知道的。


### Pod设计模式
Pod = “进程组”
Pod在k8s里面只有一个逻辑单位，不存在真实对应的东西，真正在物理上存在的东西就是几个容器。Pod是k8s分配资源的一个单位，因为里面的容器要共享某些资源，所以Pod也是k8s的原子调度单位。

### 成组调度解法对比（英文叫做：Task co-scheduling问题）
**问题描述**
假如现在有两个容器，它们是紧密协作的，所以它们应该被部署在一个 Pod 里面。具体来说，第一个容器叫做 App，就是业务容器，它会写日志文件；第二个容器叫做 LogCollector，它会把刚刚 App 容器写的日志文件转发到后端的 ElasticSearch 中。

两个容器的资源需求是这样的：App 容器需要 1G 内存，LogCollector 需要 0.5G 内存，而当前集群环境的可用内存是这样一个情况：Node_A：1.25G 内存，Node_B：2G 内存。

假如说现在没有 Pod 概念，就只有两个容器，这两个容器要紧密协作、运行在一台机器上。可是，如果调度器先把 App 调度到了 Node_A 上面，接下来会怎么样呢？这时你会发现：LogCollector 实际上是没办法调度到 Node_A 上的，因为资源不够。其实此时整个应用本身就已经出问题了，调度已经失败了，必须去重新调度。

**解决方案**
	1. 在 Mesos 里面，它会做一个事情，叫做资源囤积（resource hoarding）：即当所有设置了 Affinity 约束的任务都达到时，才开始统一调度，这是一个非常典型的成组调度的解法。缺点：效率损失，易产生死锁，复杂度增加；
	2. 乐观调度：不管这些冲突的异常情况，先调度，同时设置一个非常精妙的回滚机制，这样经过冲突后，通过回滚来解决问题。这个方式相对来说要更加优雅，也更加高效，但是它的实现机制是非常复杂的。悲观锁的设置一定比乐观锁要简单。缺点：实现非常复杂
	3. Pod完美解决，多个容器属于同一个pod，在调度的时候以一个Pod为单位进行调度的，所以这个问题根本不存在。


### 什么是超亲密关系？
* 比如说两个进程之间会发生文件交换，前面提到的例子就是这样，一个写日志，一个读日志；
* 两个进程之间需要通过 localhost 或者说是本地的 Socket 去进行通信，这种本地通信也是超亲密关系；
* 这两个容器或者是微服务之间，需要发生非常频繁的 RPC 调用，出于性能的考虑，也希望它们是超亲密关系；
* 两个容器或者是应用，它们需要共享某些 Linux Namespace。最简单常见的一个例子，就是我有一个容器需要加入另一个容器的 Network Namespace。这样我就能看到另一个容器的网络设备，和它的网络信息。

### Pod主要解决了两个问题
1. 我们怎么去描述超亲密关系；
2. 我们怎么去对超亲密关系的容器或者说是业务去做统一调度，这是 Pod 最主要的一个诉求。

	
## Pod的实现机制
因为容器之间原本是被 Linux Namespace 和 cgroups 隔开的，所以现在实际要解决的是怎么去打破这个隔离，然后共享某些事情和某些信息。这就是 Pod 的设计要解决的核心问题所在。
	1. 共享网络
		- 在每个 Pod 里，会额外起一个 Infra container 小容器来共享整个 Pod 的  Network Namespace。
		- Infra container 是一个非常小的镜像，大概 100~200KB 左右，是一个汇编语言写的、永远处于“暂停”状态的容器。由于有了这样一个 Infra container 之后，其他所有容器都会通过 Join Namespace 的方式加入到 Infra container 的 Network Namespace 中。
		- 整个 Pod 的生命周期是等同于 Infra container 的生命周期
	2. 共享存储
		- 挂载 volume 解决


## Pod的属性
#### 如何定义一个pod.yaml
```yaml
apiVersion: v1  #版本
kind: Pod  #对象类型
metadata:   #用于唯一区分对象的元数据
  name: nginx  #Pod名称
  labels:
    app: nginx #标签，其他控制器对象可以通过这样的label来定位到此Pod，从而对Pod进行管理。
spec:
  containers:
  - name: nginx  #容器名称
    image: nginx  #镜像文件
    ports:
    - containerPort: 80  #容器端口
```

#### 共享资源
	- PID命名空间：Pod中不同的应用程序可以看到其他应用程序的进程ID。
	- network命名空间：Pod中多个容器处于同一个网络命名空间，因此能够访问的IP和端口范围都是相同的。也可以通过localhost相互访问。
	- IPC命名空间：Pod中的多个容器共享Inner-process Communication命名空间，因此可以通过SystemV IPC或POSIX进行进程间通信。
	- UTS命名空间：Pod中的多个容器共享同一个主机名。
	- Volumes：Pod中各个容器可以共享在Pod中定义分存储卷（Volume）。

## 生命周期
Pod的生命周期是Replication Controller进行管理的。一个Pod的生命周期过程包括：
	* 通过yaml或json对Pod进行描述
	* apiserver（运行在Master主机）收到创建Pod的请求后，将此Pod对象的定义存储在etcd中
	* scheduler（运行在Master主机）将此Pod分配到Node上运行
	* Pod内所有容器运行结束后此Pod也结束
在整个过程中，Pod通常处于以下的五种阶段之一：
	* Pending：Pod定义正确，提交到Master，但其所包含的容器镜像还未完全创建。通常，Master对Pod进行调度需要一些时间，Node进行容器镜像的下载也需要一些时间，启动容器也需要一定时间。（写数据到etcd，调度，pull镜像，启动容器）。
	* Running：Pod已经被分配到某个Node上，并且所有的容器都被创建完毕，至少有一个容器正在运行中，或者有容器正在启动或重启中。
	* Succeeded：Pod中所有的容器都成功运行结束，并且不会被重启。这是Pod的一种最终状态。
	* Failed：Pod中所有的容器都运行结束了，其中至少有一个容器是非正常结束的（exit code不是0）。这也是Pod的一种最终状态。
	* Unknown：无法获得Pod的状态，通常是由于无法和Pod所在的Node进行通信。

## 总结
* Pod 是 Kubernetes 项目里实现“容器设计模式”的核心机制；
* “容器设计模式”是 Google Borg 的大规模容器集群管理最佳实践之一，也是 Kubernetes 进行复杂应用编排的基础依赖之一；
* 所有“设计模式”的本质都是：解耦和重用。


## 参考链接

如何操作[K8s | Pod 基本操作 - 简书](https://www.jianshu.com/p/9ce65e37f746)
pod简介[K8s — Pod - 简书](https://www.jianshu.com/p/74f53019a726)
pod和设计模式[从零开始入门 K8s| 详解 Pod 及容器设计模式-云栖社区-阿里云](https://yq.aliyun.com/articles/718827?utm_content=g_1000077419)	